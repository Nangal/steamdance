// Generated by CoffeeScript 1.7.1
(function() {
  var Simulator, cardinal_dirs, fill, parseXY, sign;

  cardinal_dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];

  fill = function(initial_square, f) {
    var hmm, n, ok, to_explore, visited;
    visited = {};
    visited["" + initial_square.x + "," + initial_square.y] = true;
    to_explore = [initial_square];
    hmm = function(x, y) {
      var k;
      k = "" + x + "," + y;
      if (!visited[k]) {
        visited[k] = true;
        return to_explore.push({
          x: x,
          y: y
        });
      }
    };
    while (n = to_explore.shift()) {
      ok = f(n.x, n.y, hmm);
      if (ok) {
        hmm(n.x + 1, n.y);
        hmm(n.x - 1, n.y);
        hmm(n.x, n.y + 1);
        hmm(n.x, n.y - 1);
      }
    }
  };

  parseXY = function(k) {
    var x, y, _ref;
    _ref = k.split(/,/), x = _ref[0], y = _ref[1];
    return {
      x: parseInt(x),
      y: parseInt(y)
    };
  };

  sign = function(x) {
    if (x > 0) {
      return 1;
    } else if (x < 0) {
      return -1;
    } else {
      return 0;
    }
  };

  Simulator = (function() {
    function Simulator(grid) {
      var k, v, x, y, _ref, _ref1;
      this.grid = grid;
      this.grid || (this.grid = {});
      this.engines = {};
      _ref = this.grid;
      for (k in _ref) {
        v = _ref[k];
        if (v === 'positive' || v === 'negative') {
          _ref1 = parseXY(k), x = _ref1.x, y = _ref1.y;
          this.engines[k] = {
            x: x,
            y: y
          };
        }
      }
      this.delta = {
        changed: {},
        sound: {}
      };
    }

    Simulator.prototype.set = function(x, y, v) {
      var k, _ref;
      k = "" + x + "," + y;
      if (v != null) {
        this.grid[k] = v;
        this.delta.changed[k] = v;
        delete this.engines[k];
        if (v === 'positive' || v === 'negative') {
          return this.engines[k] = {
            x: x,
            y: y
          };
        }
      } else {
        if ((_ref = this.grid[k]) === 'positive' || _ref === 'negative') {
          delete this.engines[k];
        }
        delete this.grid[k];
        return this.delta.changed[k] = null;
      }
    };

    Simulator.prototype.get = function(x, y) {
      return this.grid["" + x + "," + y];
    };

    Simulator.prototype.getGrid = function() {
      return this.grid;
    };

    Simulator.prototype.tryMove = function(points, dx, dy) {
      var isMe, shuttle, x, y, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      dx = dx < 0 ? -1 : dx > 0 ? 1 : 0;
      dy = dy < 0 ? -1 : dy > 0 ? 1 : 0;
      if (dx && dy) {
        throw new Error('one at a time, fellas');
      }
      if (!(dx || dy)) {
        return;
      }
      isMe = function(qx, qy) {
        var x, y, _i, _len, _ref;
        for (_i = 0, _len = points.length; _i < _len; _i++) {
          _ref = points[_i], x = _ref.x, y = _ref.y;
          if (x === qx && y === qy) {
            return true;
          }
        }
        return false;
      };
      for (_i = 0, _len = points.length; _i < _len; _i++) {
        _ref = points[_i], x = _ref.x, y = _ref.y;
        if (!isMe(x + dx, y + dy)) {
          if (this.get(x + dx, y + dy) !== 'nothing') {
            return false;
          }
        }
      }
      shuttle = {};
      for (_j = 0, _len1 = points.length; _j < _len1; _j++) {
        _ref1 = points[_j], x = _ref1.x, y = _ref1.y;
        shuttle["" + x + "," + y] = this.get(x, y);
        this.set(x, y, 'nothing');
      }
      for (_k = 0, _len2 = points.length; _k < _len2; _k++) {
        _ref2 = points[_k], x = _ref2.x, y = _ref2.y;
        this.set(x + dx, y + dy, shuttle["" + x + "," + y]);
      }
      return true;
    };

    Simulator.prototype.getPressure = function() {
      var direction, k, pressure, v, _ref;
      pressure = {};
      _ref = this.engines;
      for (k in _ref) {
        v = _ref[k];
        direction = 'positive' === this.get(v.x, v.y) ? 1 : -1;
        fill(v, (function(_this) {
          return function(x, y, hmm) {
            var c, cell, dx, dy, _i, _len, _ref1, _ref2, _ref3, _x, _y;
            cell = _this.get(x, y);
            if (x === v.x && y === v.y) {
              cell = 'nothing';
            }
            if (cell === 'nothing' || cell === 'thinshuttle' || cell === 'thinsolid') {
              pressure["" + x + "," + y] = ((_ref1 = pressure["" + x + "," + y]) != null ? _ref1 : 0) + direction;
              for (_i = 0, _len = cardinal_dirs.length; _i < _len; _i++) {
                _ref2 = cardinal_dirs[_i], dx = _ref2[0], dy = _ref2[1];
                _x = x + dx;
                _y = y + dy;
                if (_this.get(_x, _y) === 'bridge') {
                  while ((c = _this.get(_x, _y)) === 'bridge') {
                    pressure["" + _x + "," + _y] = ((_ref3 = pressure["" + _x + "," + _y]) != null ? _ref3 : 0) + direction;
                    _x += dx;
                    _y += dy;
                  }
                  if (c === 'nothing' || c === 'thinshuttle' || c === 'thinsolid') {
                    hmm(_x, _y);
                  }
                }
              }
              return true;
            }
            return false;
          };
        })(this));
      }
      return pressure;
    };

    Simulator.prototype.step = function() {
      var direction, dx, dy, force, getShuttle, k, movedX, movedY, points, shuttleMap, shuttles, thisDelta, v, x, y, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
      shuttleMap = {};
      shuttles = [];
      getShuttle = (function(_this) {
        return function(x, y) {
          var s, _ref;
          if ((_ref = _this.get(x, y)) !== 'shuttle') {
            return null;
          }
          s = shuttleMap["" + x + "," + y];
          if (s) {
            return s;
          }
          shuttles.push((s = {
            points: [],
            force: {
              x: 0,
              y: 0
            }
          }));
          fill({
            x: x,
            y: y
          }, function(x, y) {
            var _ref1;
            if ((_ref1 = _this.get(x, y)) === 'shuttle' || _ref1 === 'thinshuttle') {
              shuttleMap["" + x + "," + y] = s;
              s.points.push({
                x: x,
                y: y
              });
              return true;
            } else {
              return false;
            }
          });
          return s;
        };
      })(this);
      _ref = this.engines;
      for (k in _ref) {
        v = _ref[k];
        direction = 'positive' === this.get(v.x, v.y) ? 1 : -1;
        fill(v, (function(_this) {
          return function(x, y, hmm) {
            var c, cell, dx, dy, s, _i, _len, _ref1, _x, _y;
            cell = _this.get(x, y);
            if (x === v.x && y === v.y) {
              cell = 'nothing';
            }
            switch (cell) {
              case 'nothing':
              case 'thinshuttle':
              case 'thinsolid':
                for (_i = 0, _len = cardinal_dirs.length; _i < _len; _i++) {
                  _ref1 = cardinal_dirs[_i], dx = _ref1[0], dy = _ref1[1];
                  _x = x + dx;
                  _y = y + dy;
                  if ((s = getShuttle(_x, _y))) {
                    s.force.x += dx * direction;
                    s.force.y += dy * direction;
                  } else if (_this.get(_x, _y) === 'bridge') {
                    _x += dx;
                    _y += dy;
                    while ((c = _this.get(_x, _y)) === 'bridge') {
                      _x += dx;
                      _y += dy;
                    }
                    if ((s = getShuttle(_x, _y))) {
                      s.force.x += dx * direction;
                      s.force.y += dy * direction;
                    } else if (c === 'nothing' || c === 'thinshuttle' || c === 'thinsolid') {
                      hmm(_x, _y);
                    }
                  }
                }
                return true;
              default:
                return false;
            }
          };
        })(this));
      }
      for (_i = 0, _len = shuttles.length; _i < _len; _i++) {
        _ref1 = shuttles[_i], points = _ref1.points, force = _ref1.force;
        movedY = this.tryMove(points, 0, force.y);
        dy = movedY ? sign(force.y) : 0;
        if (!movedY) {
          movedX = this.tryMove(points, force.x, 0);
          dx = movedX ? sign(force.x) : 0;
        } else {
          dx = 0;
        }
        if (dx || dy) {
          for (_j = 0, _len1 = points.length; _j < _len1; _j++) {
            _ref2 = points[_j], x = _ref2.x, y = _ref2.y;
            if ((_ref3 = this.get(x + 2 * dx, y + 2 * dy)) === (void 0)) {
              this.delta.sound["" + x + "," + y] = true;
            }
          }
        }
      }
      thisDelta = this.delta;
      this.delta = {
        changed: {},
        sound: {}
      };
      return thisDelta;
    };

    return Simulator;

  })();

  Simulator.parseXY = parseXY;

  if (typeof module !== 'undefined') {
    module.exports = Simulator;
  } else {
    this.Simulator = Simulator;
  }

}).call(this);

//# sourceMappingURL=simulator.map
