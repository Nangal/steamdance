// Generated by CoffeeScript 1.7.1
var Boilerplate, parseXY,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

parseXY = Simulator.parseXY;

Boilerplate = (function() {
  var CELL_SIZE, clamp, enclosingRect, line;

  Boilerplate.colors = {
    bridge: 'hsl(203, 67%, 51%)',
    negative: 'hsl(16, 68%, 50%)',
    nothing: 'hsl(0, 0%, 100%)',
    positive: 'hsl(120, 52%, 58%)',
    shuttle: 'hsl(283, 65%, 45%)',
    solid: 'hsl(184, 49%, 7%)',
    thinshuttle: 'hsl(283, 89%, 75%)',
    thinsolid: 'hsl(0, 0%, 71%)'
  };

  Boilerplate.darkColors = {
    bridge: "hsl(203,34%,43%)",
    negative: "hsl(16,40%,36%)",
    nothing: "hsl(0, 0%, 49%)",
    positive: "hsl(120,30%,43%)",
    shuttle: "hsl(287,24%,33%)",
    solid: "hsl(249,3%,45%)",
    thinshuttle: "hsl(283,31%,49%)",
    thinsolid: "hsl(0, 0%, 49%)"
  };

  line = function(x0, y0, x1, y1, f) {
    var dx, dy, e, e1, e2, i, ix, iy, _i, _ref;
    dx = Math.abs(x1 - x0);
    dy = Math.abs(y1 - y0);
    ix = x0 < x1 ? 1 : -1;
    iy = y0 < y1 ? 1 : -1;
    e = 0;
    for (i = _i = 0, _ref = dx + dy; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      f(x0, y0);
      e1 = e + dy;
      e2 = e - dx;
      if (Math.abs(e1) < Math.abs(e2)) {
        x0 += ix;
        e = e1;
      } else {
        y0 += iy;
        e = e2;
      }
    }
  };

  enclosingRect = function(a, b) {
    return {
      tx: Math.min(a.tx, b.tx),
      ty: Math.min(a.ty, b.ty),
      tw: Math.abs(b.tx - a.tx) + 1,
      th: Math.abs(b.ty - a.ty) + 1
    };
  };

  clamp = function(x, min, max) {
    return Math.max(Math.min(x, max), min);
  };

  Boilerplate.activeTool = 'nothing';

  Boilerplate.changeTool = function(newTool) {
    this.activeTool = newTool === 'solid' ? null : newTool;
    return typeof this.onToolChanged === "function" ? this.onToolChanged(this.activeTool) : void 0;
  };

  Boilerplate.addKeyListener = function(el) {
    return el.addEventListener('keydown', (function(_this) {
      return function(e) {
        var kc, newTool, _ref, _ref1;
        kc = e.keyCode;
        newTool = {
          49: 'nothing',
          50: 'solid',
          51: 'positive',
          52: 'negative',
          53: 'shuttle',
          54: 'thinshuttle',
          55: 'thinsolid',
          56: 'bridge',
          80: 'positive',
          78: 'negative',
          83: 'shuttle',
          65: 'thinshuttle',
          69: 'nothing',
          71: 'thinsolid',
          68: 'solid',
          66: 'bridge'
        }[kc];
        if (newTool) {
          _this.changeTool(newTool);
        }
        return (_ref = document.activeElement) != null ? (_ref1 = _ref.boilerplate) != null ? _ref1.draw() : void 0 : void 0;
      };
    })(this));
  };

  CELL_SIZE = 20;

  Boilerplate.prototype.screenToWorld = function(px, py) {
    var tx, ty;
    if (px == null) {
      return {
        tx: null,
        ty: null
      };
    }
    px += Math.floor(this.scroll_x * this.size);
    py += Math.floor(this.scroll_y * this.size);
    tx = Math.floor(px / this.size);
    ty = Math.floor(py / this.size);
    return {
      tx: tx,
      ty: ty
    };
  };

  Boilerplate.prototype.worldToScreen = function(tx, ty) {
    if (tx == null) {
      return {
        px: null,
        py: null
      };
    }
    return {
      px: tx * this.size - Math.floor(this.scroll_x * this.size),
      py: ty * this.size - Math.floor(this.scroll_y * this.size)
    };
  };

  Boilerplate.prototype.zoomBy = function(diff) {
    this.zoomLevel += diff;
    this.zoomLevel = clamp(this.zoomLevel, 1 / CELL_SIZE, 5);
    return this.size = Math.floor(CELL_SIZE * this.zoomLevel);
  };

  function Boilerplate(el, options) {
    var _ref;
    this.el = el;
    this.zoomLevel = 1;
    this.zoomBy(0);
    if (options instanceof Simulator) {
      options = {
        simulator: options
      };
    }
    this.simulator = options.simulator || new Simulator();
    this.scroll_x = options.initialX || 0;
    this.scroll_y = options.initialY || 0;
    this.canScroll = (_ref = options.canScroll) != null ? _ref : true;
    if (this.el.tabIndex === -1) {
      this.el.tabIndex = 0;
    }
    this.canvas = this.el.appendChild(document.createElement('canvas'));
    this.canvas.className = 'draw';
    this.uiCanvas = this.el.appendChild(document.createElement('canvas'));
    this.uiCanvas.className = 'ui';
    this.uiCanvas.style.pointerEvents = 'none';
    this.el.boilerplate = this;
    this.resizeTo(el.offsetWidth, el.offsetHeight);
    this.mouse = {
      x: null,
      y: null,
      mode: null
    };
    this.imminent_select = false;
    this.selectedA = this.selectedB = null;
    this.selectOffset = null;
    this.selection = null;
    this.draw();
    this.el.onkeydown = (function(_this) {
      return function(e) {
        var kc;
        kc = e.keyCode;
        switch (kc) {
          case 37:
            if (_this.canScroll) {
              _this.scroll_x -= 1;
            }
            break;
          case 39:
            if (_this.canScroll) {
              _this.scroll_x += 1;
            }
            break;
          case 38:
            if (_this.canScroll) {
              _this.scroll_y -= 1;
            }
            break;
          case 40:
            if (_this.canScroll) {
              _this.scroll_y += 1;
            }
            break;
          case 16:
            _this.imminent_select = true;
            break;
          case 27:
            _this.selection = _this.selectOffset = null;
            break;
          case 88:
            if (_this.selection) {
              _this.flip('x');
            }
            break;
          case 89:
            if (_this.selection) {
              _this.flip('y');
            }
            break;
          case 77:
            if (_this.selection) {
              _this.mirror();
            }
        }
        return _this.draw();
      };
    })(this);
    this.el.onkeyup = (function(_this) {
      return function(e) {
        if (e.keyCode === 16) {
          _this.imminent_select = false;
          return _this.draw();
        }
      };
    })(this);
    this.el.addEventListener('blur', (function(_this) {
      return function() {
        _this.mouse.mode = null;
        return _this.imminent_select = false;
      };
    })(this));
    this.el.onmousemove = (function(_this) {
      return function(e) {
        var _ref1;
        _this.imminent_select = !!e.shiftKey;
        if (e.button && !_this.mouse.mode) {
          _this.el.onmousedown(e);
        }
        _this.mouse.from = {
          tx: _this.mouse.tx,
          ty: _this.mouse.ty
        };
        _this.mouse.x = clamp(e.offsetX, 0, _this.el.offsetWidth - 1);
        _this.mouse.y = clamp(e.offsetY, 0, _this.el.offsetHeight - 1);
        _ref1 = _this.screenToWorld(_this.mouse.x, _this.mouse.y), _this.mouse.tx = _ref1.tx, _this.mouse.ty = _ref1.ty;
        switch (_this.mouse.mode) {
          case 'paint':
            _this.paint();
            break;
          case 'select':
            _this.selectedB = _this.screenToWorld(_this.mouse.x, _this.mouse.y);
        }
        return _this.draw();
      };
    })(this);
    this.el.onmousedown = (function(_this) {
      return function(e) {
        if (e.shiftKey) {
          _this.mouse.mode = 'select';
          _this.selection = _this.selectOffset = null;
          _this.selectedA = _this.screenToWorld(_this.mouse.x, _this.mouse.y);
          _this.selectedB = _this.selectedA;
        } else if (_this.selection) {
          _this.stamp();
        } else {
          _this.mouse.mode = 'paint';
          _this.mouse.from = {
            tx: _this.mouse.tx,
            ty: _this.mouse.ty
          };
          _this.paint();
        }
        return _this.draw();
      };
    })(this);
    this.el.onmouseup = (function(_this) {
      return function() {
        if (_this.mouse.mode === 'select') {
          _this.selection = _this.copySubgrid(enclosingRect(_this.selectedA, _this.selectedB));
          _this.selectOffset = {
            tx: _this.selectedB.tx - Math.min(_this.selectedA.tx, _this.selectedB.tx),
            ty: _this.selectedB.ty - Math.min(_this.selectedA.ty, _this.selectedB.ty)
          };
        }
        _this.mouse.mode = null;
        _this.imminent_select = false;
        return typeof _this.onEditFinish === "function" ? _this.onEditFinish() : void 0;
      };
    })(this);
    this.el.onmouseout = (function(_this) {
      return function(e) {
        _this.el.onmousemove(e);
        _this.mouse.x = _this.mouse.y = _this.mouse.from = _this.mouse.tx = _this.mouse.ty = null;
        return _this.mouse.mode = null;
      };
    })(this);
    this.el.onmouseenter = (function(_this) {
      return function(e) {
        if (e.which) {
          return _this.el.onmousedown(e);
        }
      };
    })(this);
    this.el.onmousewheel = (function(_this) {
      return function(e) {
        var oldsize;
        if (!_this.canScroll) {
          return;
        }
        if (e.shiftKey) {
          oldsize = _this.size;
          _this.zoomBy(e.wheelDeltaY / 800);
          _this.scroll_x += _this.mouse.x / oldsize - _this.mouse.x / _this.size;
          _this.scroll_y += _this.mouse.y / oldsize - _this.mouse.y / _this.size;
        } else {
          _this.scroll_x += e.wheelDeltaX / (-2 * _this.size);
          _this.scroll_y += e.wheelDeltaY / (-2 * _this.size);
        }
        e.preventDefault();
        return _this.draw();
      };
    })(this);
  }

  Boilerplate.prototype.resizeTo = function(width, height) {
    this.uiCanvas.width = this.canvas.width = width * devicePixelRatio;
    this.uiCanvas.height = this.canvas.height = height * devicePixelRatio;
    this.ctx = this.canvas.getContext('2d');
    this.ctx.scale(devicePixelRatio, devicePixelRatio);
    return this.draw();
  };

  Boilerplate.prototype.paint = function() {
    var fromtx, fromty, tx, ty, _ref, _ref1;
    if (Boilerplate.activeTool === 'move') {
      throw 'Invalid placing';
    }
    _ref = this.mouse, tx = _ref.tx, ty = _ref.ty;
    _ref1 = this.mouse.from, fromtx = _ref1.tx, fromty = _ref1.ty;
    if (fromtx == null) {
      fromtx = tx;
    }
    if (fromty == null) {
      fromty = ty;
    }
    return line(fromtx, fromty, tx, ty, (function(_this) {
      return function(x, y) {
        _this.simulator.set(x, y, Boilerplate.activeTool);
        return typeof _this.onEdit === "function" ? _this.onEdit(x, y, Boilerplate.activeTool) : void 0;
      };
    })(this));
  };

  Boilerplate.prototype.copySubgrid = function(rect) {
    var s, subgrid, th, tw, tx, ty, x, y, _i, _j, _ref, _ref1;
    tx = rect.tx, ty = rect.ty, tw = rect.tw, th = rect.th;
    subgrid = {
      tw: tw,
      th: th
    };
    for (y = _i = ty, _ref = ty + th; ty <= _ref ? _i <= _ref : _i >= _ref; y = ty <= _ref ? ++_i : --_i) {
      for (x = _j = tx, _ref1 = tx + tw; tx <= _ref1 ? _j <= _ref1 : _j >= _ref1; x = tx <= _ref1 ? ++_j : --_j) {
        if (s = this.simulator.grid[[x, y]]) {
          subgrid[[x - tx, y - ty]] = s;
        }
      }
    }
    return subgrid;
  };

  Boilerplate.prototype.flip = function(dir) {
    var k, new_selection, th, tw, tx, tx_, ty, ty_, v, _ref, _ref1;
    if (!this.selection) {
      return;
    }
    new_selection = {
      tw: tw = this.selection.tw,
      th: th = this.selection.th
    };
    _ref = this.selection;
    for (k in _ref) {
      v = _ref[k];
      _ref1 = parseXY(k), tx = _ref1.x, ty = _ref1.y;
      tx_ = __indexOf.call(dir, 'x') >= 0 ? tw - 1 - tx : tx;
      ty_ = __indexOf.call(dir, 'y') >= 0 ? th - 1 - ty : ty;
      new_selection[[tx_, ty_]] = v;
    }
    return this.selection = new_selection;
  };

  Boilerplate.prototype.mirror = function() {
    var k, new_selection, th, tw, tx, ty, v, _ref, _ref1;
    if (!this.selection) {
      return;
    }
    new_selection = {
      tw: tw = this.selection.th,
      th: th = this.selection.tw
    };
    _ref = this.selection;
    for (k in _ref) {
      v = _ref[k];
      _ref1 = parseXY(k), tx = _ref1.x, ty = _ref1.y;
      new_selection[[ty, tx]] = v;
    }
    return this.selection = new_selection;
  };

  Boilerplate.prototype.stamp = function() {
    var mtx, mty, s, tx, ty, x, y, _i, _ref, _ref1, _results;
    if (!this.selection) {
      throw new Error('tried to stamp without a selection');
    }
    _ref = this.screenToWorld(this.mouse.x, this.mouse.y), mtx = _ref.tx, mty = _ref.ty;
    mtx -= this.selectOffset.tx;
    mty -= this.selectOffset.ty;
    _results = [];
    for (y = _i = 0, _ref1 = this.selection.th; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; y = 0 <= _ref1 ? ++_i : --_i) {
      _results.push((function() {
        var _j, _ref2, _results1;
        _results1 = [];
        for (x = _j = 0, _ref2 = this.selection.tw; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; x = 0 <= _ref2 ? ++_j : --_j) {
          tx = mtx + x;
          ty = mty + y;
          if ((s = this.selection[[x, y]]) !== this.simulator.get(tx, ty)) {
            this.simulator.set(tx, ty, s);
            _results1.push(typeof this.onEdit === "function" ? this.onEdit(tx, ty, s) : void 0);
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  Boilerplate.prototype.copy = function(e) {
    if (this.selection) {
      e.clipboardData.setData('text', JSON.stringify(this.selection));
      console.log(JSON.stringify(this.selection));
    }
    return e.preventDefault();
  };

  Boilerplate.prototype.paste = function(e) {
    var data;
    console.log('paste');
    data = e.clipboardData.getData('text');
    if (data) {
      try {
        this.selection = JSON.parse(data);
        return this.selectOffset = {
          tx: 0,
          ty: 0
        };
      } catch (_error) {}
    }
  };

  Boilerplate.prototype.draw = function() {
    if (this.needsDraw) {
      return;
    }
    this.needsDraw = true;
    return requestAnimationFrame((function(_this) {
      return function() {
        _this.drawFrame();
        return _this.needsDraw = false;
      };
    })(this));
  };

  Boilerplate.prototype.drawFrame = function() {
    this.ctx.fillStyle = Boilerplate.colors['solid'];
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    this.drawGrid();
    return this.drawEditControls();
  };

  Boilerplate.prototype.drawGrid = function() {
    var k, p, pressure, px, py, tx, ty, v, v2, zeroPos, _ref, _ref1, _ref2;
    pressure = this.simulator.getPressure();
    _ref = this.simulator.grid;
    for (k in _ref) {
      v = _ref[k];
      _ref1 = parseXY(k), tx = _ref1.x, ty = _ref1.y;
      _ref2 = this.worldToScreen(tx, ty), px = _ref2.px, py = _ref2.py;
      if (px + this.size >= 0 && px < this.canvas.width && py + this.size >= 0 && py < this.canvas.height) {
        this.ctx.fillStyle = Boilerplate.colors[v];
        this.ctx.fillRect(px, py, this.size, this.size);
        if (v === 'nothing' && (v2 = this.simulator.get(tx, ty - 1)) !== 'nothing') {
          this.ctx.fillStyle = Boilerplate.darkColors[v2 != null ? v2 : 'solid'];
          this.ctx.fillRect(px, py, this.size, this.size * 0.3);
        }
        if ((p = pressure[k]) && p !== 0) {
          this.ctx.fillStyle = p < 0 ? 'rgba(255,0,0,0.2)' : 'rgba(0,255,0,0.15)';
          this.ctx.fillRect(px, py, this.size, this.size);
        }

        /*
        me = v in ['shuttle', 'thinshuttle']
        up = @simulator.get(tx,ty-1) in ['shuttle', 'thinshuttle']
        left = @simulator.get(tx-1,ty) in ['shuttle', 'thinshuttle']
        if (me and not up) or (not me and up)
          @ctx.globalAlpha = 0.5
          @ctx.fillStyle = 'black'
          @ctx.fillRect px, py, @size, 2
        if (me and not left) or (not me and left)
          @ctx.globalAlpha = 0.3
          @ctx.fillStyle = 'black'
          @ctx.fillRect px, py, 2, @size
        @ctx.globalAlpha = 1
         */
      }
    }
    zeroPos = this.worldToScreen(0, 0);
    this.ctx.lineWidth = 3;
    return this.ctx.strokeStyle = 'yellow';
  };

  Boilerplate.prototype.drawEditControls = function() {
    var mpx, mpy, mtx, mty, mx, my, px, py, sa, sb, th, tw, tx, ty, v, x, y, _i, _j, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
    mx = this.mouse.x;
    my = this.mouse.y;
    _ref = this.screenToWorld(mx, my), mtx = _ref.tx, mty = _ref.ty;
    _ref1 = this.worldToScreen(mtx, mty), mpx = _ref1.px, mpy = _ref1.py;
    if (this.mouse.mode === 'select') {
      sa = this.selectedA;
      sb = this.selectedB;
    } else if (this.imminent_select) {
      sa = sb = {
        tx: mtx,
        ty: mty
      };
    }
    this.ctx.lineWidth = 1;
    if (this.mouse.tx !== null) {
      if (sa) {
        _ref2 = enclosingRect(sa, sb), tx = _ref2.tx, ty = _ref2.ty, tw = _ref2.tw, th = _ref2.th;
        _ref3 = this.worldToScreen(tx, ty), px = _ref3.px, py = _ref3.py;
        this.ctx.fillStyle = 'rgba(0,0,255,0.5)';
        this.ctx.fillRect(px, py, tw * this.size, th * this.size);
        this.ctx.strokeStyle = 'rgba(0,255,255,0.5)';
        this.ctx.strokeRect(px, py, tw * this.size, th * this.size);
      } else if (this.selection) {
        this.ctx.globalAlpha = 0.8;
        for (y = _i = 0, _ref4 = this.selection.th; 0 <= _ref4 ? _i < _ref4 : _i > _ref4; y = 0 <= _ref4 ? ++_i : --_i) {
          for (x = _j = 0, _ref5 = this.selection.tw; 0 <= _ref5 ? _j < _ref5 : _j > _ref5; x = 0 <= _ref5 ? ++_j : --_j) {
            _ref6 = this.worldToScreen(x + mtx - this.selectOffset.tx, y + mty - this.selectOffset.ty), px = _ref6.px, py = _ref6.py;
            if (px + this.size >= 0 && px < this.canvas.width && py + this.size >= 0 && py < this.canvas.height) {
              v = this.selection[[x, y]];
              this.ctx.fillStyle = v ? Boilerplate.colors[v] : Boilerplate.colors['solid'];
              this.ctx.fillRect(px, py, this.size, this.size);
            }
          }
        }
        this.ctx.strokeStyle = 'rgba(0,255,255,0.5)';
        this.ctx.strokeRect(mpx - this.selectOffset.tx * this.size, mpy - this.selectOffset.ty * this.size, this.selection.tw * this.size, this.selection.th * this.size);
        this.ctx.globalAlpha = 1;
      } else if (mpx != null) {
        this.ctx.fillStyle = Boilerplate.colors[(_ref7 = Boilerplate.activeTool) != null ? _ref7 : 'solid'];
        this.ctx.fillRect(mpx + this.size / 4, mpy + this.size / 4, this.size / 2, this.size / 2);
        this.ctx.strokeStyle = this.simulator.get(mtx, mty) ? 'black' : 'white';
        this.ctx.strokeRect(mpx + 1, mpy + 1, this.size - 2, this.size - 2);
      }
    }
  };

  return Boilerplate;

})();
